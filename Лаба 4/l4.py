from itertools import product, zip_longest

from numpy import copy, s_

def char_to_int(c):
    return ord(c) - 48

def char_list_to_int_list(Z):
    X = list()
    for z in Z:
        X.append(char_to_int(z))
    return X

def F(x,y,s):
    n = len(x)
    z = list()
    for i in range(n):
        z_i = (s[i] * x[i]) ^ (1 ^ s[i])*y[i]
        z.append(z_i)
    return z

def shift_list(lst):
    return lst[1:] + lst[:1]    


Z = "10001001110110011100110110100110010100010010011101110011111100000100001111010011010001001000111001001101110110000111111011010000100000101110111111100110111101011101001110101011010101011010011000100110101001111101010001010001110101001011101000100010100011000011010000011111001011001110110011100010101100110111010100000011000001111101111010001100010010101100111011111110011111100001111011001011011100110111110101111100001001100101100011001100100010111111001010001111011101110000001010010000010000111100101110011001101011010100100010111010011011101000010001011110010101010110011001111010010110000100001100011101010000110100010010111011011101101101010111111100101100000101110010101001111110001110110101101000001110101110011110111001001000100110010110111000000110001000101000011010011101100110111010011101110001100010010000011011111000110101111011111100000011101100010011000000111011100011010110001010100010010111101111110110111001001101100001110111110001110100100111110110101101011001000101011001100101101001111001010011001000000101001111001010001111010111001000100111101110010101000011010101100100011101000001101010010011011100000100110101100100101010010111111000100010110010000100111101101010100111010001100111110111100000101101100000101111011000011000000010100010010010100100101011101100110110110010011011000101111101100010101001110011000111111010100101010100001110000101011101111010111110010101110100000011110111100110100110110001100000010000100011111100111101100110100111110110011000011100100010110111101111100110000001000010000011100110101010110010000110110001011010111010100010010011001111101110111110010001101100001001111100110101011110000011100100001000010110000011110100111001011010011011101101000111111100001110011001000000001101101101010111010011111111000111111101001010100010101110111100010111110010001100001101100010100010110100110010000000010110101111010010011000110011101010000010100111101111000011011001101010001100100100010011110010010111000111100000110110001011000101111000100100101001011011011010000100010111110001000111010010011100"
N = len(Z)
Z = char_list_to_int_list(Z)





def giffy(x,y,s):
    return (s*x) ^ ((1^s) * y)

def compare():
    x_g = [0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1]
    y_g = [1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1]
    s_g = [0, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1]
    for i in range(175):
        x_g.append(x_g[i] ^ x_g[i+3])
    for i in range(174):
        y_g.append(y_g[i] ^ y_g[i+1] ^ y_g[i+2] ^ y_g[i+6])
    for i in range(173):
        s_g.append(s_g[i] ^ s_g[i+1] ^ s_g[i+2] ^ s_g[i+5])
    
    F_cons = []
    f = open('compare.txt', 'a')
    f.write('Z = 10001001110110011100110110100110010100010010011101110011111100000100001111010011010001001000111001001101110110000111111011010000100000101110111111100110111101011101001110101011010101011010011000100110101001111101010001010001110101001011101000100010100011000011010000011111001011001110110011100010101100110111010100000011000001111101111010001100010010101100111011111110011111100001111011001011011100110111110101111100001001100101100011001100100010111111001010001111011101110000001010010000010000111100101110011001101011010100100010111010011011101000010001011110010101010110011001111010010110000100001100011101010000110100010010111011011101101101010111111100101100000101110010101001111110001110110101101000001110101110011110111001001000100110010110111000000110001000101000011010011101100110111010011101110001100010010000011011111000110101111011111100000011101100010011000000111011100011010110001010100010010111101111110110111001001101100001110111110001110100100111110110101101011001000101011001100101101001111001010011001000000101001111001010001111010111001000100111101110010101000011010101100100011101000001101010010011011100000100110101100100101010010111111000100010110010000100111101101010100111010001100111110111100000101101100000101111011000011000000010100010010010100100101011101100110110110010011011000101111101100010101001110011000111111010100101010100001110000101011101111010111110010101110100000011110111100110100110110001100000010000100011111100111101100110100111110110011000011100100010110111101111100110000001000010000011100110101010110010000110110001011010111010100010010011001111101110111110010001101100001001111100110101011110000011100100001000010110000011110100111001011010011011101101000111111100001110011001000000001101101101010111010011111111000111111101001010100010101110111100010111110010001100001101100010100010110100110010000000010110101111010010011000110011101010000010100111101111000011011001101010001100100100010011110010010111000111100000110110001011000101111000100100101001011011011010000100010111110001000111010010011100')
    f.write(f'\nF = ')
    for i in range(200):
        x_i, y_i, s_i = x_g[i], y_g[i], s_g[i]
        f.write(f'{giffy(x_i,y_i,s_i)}')
    f.close()

        









def generate_x_i(n1):
    # (6) bM < 1  (M = 2^n1)
    C = 70
    N = 221
    X_i_conseqs = list() # cписок заполнений L1 которые для которых R < C

    good_iterat = 0 # итератор для "хороших" L1"
    bad_iter = 0 # итератор для "плохих" L1"
    all_iterat = 0 #итератор для всевозможных заполнений L1"
    f = open('L1.txt', 'a')
    for vect in product((0,1),repeat=n1):

        if 1 not in vect: # пропускаем вектор (0,0, ..., 0,0)
            continue

        X = list(vect) # преобразуем кортеж в список
        for k in range(N - n1): 
            X.append(X[k] ^ X[k+3]) # находим x_25, x_26, ..., x_221
        
        R = 0
        for j in range(N): # находим число совпадений между битами 
            R += (X[j] ^ Z[j]) # последовательности (x_i) и первыми N битами (z_i)

        if R < C: # если R < 70, то такое начальное заполнение L1 нам подходит
            # X_i_conseqs.append(list(vect)) # и мы его сохраняем
            f.writelines(f'{vect}\n')
            good_iterat += 1
            print(f'{good_iterat} / {all_iterat} / {2**n1}')
        else:
            bad_iter += 1
        # print(f'{good_iterat} / {bad_iter} / {all_iterat} / {2**n1} :\t {R}')
        all_iterat += 1 
    f.close()
    return f'All "good" L1 fill is in file  "{f.name}"'


def generate_y_i(n2):
    # (6) bM < 1  (M = 2^n1)
    C = 72
    N = 228

    good_iterat = 0 # итератор для "хороших" L2"
    bad_iter = 0 # итератор для "плохих" L2"
    all_iterat = 0 #итератор для всевозможных заполнений L2"
    f = open('L2.txt', 'a')
    for vect in product((0,1),repeat=n2):

        if 1 not in vect: # пропускаем вектор (0,0, ..., 0,0)
            continue

        Y = list(vect) # преобразуем кортеж в список
        for k in range(N - n2): 
            Y.append(Y[k] ^ Y[k+1] ^ Y[k+2] ^ Y[k+6]) # находим x_26, ..., x_228
        
        R = 0
        for j in range(N): # находим число совпадений между битами 
            R += (Y[j] ^ Z[j]) # последовательности (у_i) и первыми N битами (z_i)

        if R < C: # если R < 70, то такое начальное заполнение L1 нам подходит
            # X_i_conseqs.append(list(vect)) # и мы его сохраняем
            f.writelines(f'{vect}\n')
            good_iterat += 1
            # print(f'{good_iterat} / {all_iterat} / {2**n1}')
        else:
            bad_iter += 1
        if all_iterat % 100000 == 0:
            print(f'{good_iterat} / {all_iterat} / {2**n2}')
        # print(f'{good_iterat} / {bad_iter} / {all_iterat} / {2**n1} :\t {R}')
        all_iterat += 1 
    f.close()
    return f'All "good" L2 fill is in file  "{f.name}"'


X_good = [
    [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1],
    [0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1],
    [0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1],
    [0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1],
    [0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1],
    [0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1],
    [0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1],
    [0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1],
    [0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1],
    [0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1],
    [0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1],
    [0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1],
    [0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1],
    [0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1],
    [0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1],
    [0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1],
    [0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0],
    [0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1],
    [0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1],
    [0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1],
    [0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1],
    [0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1],
    [0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1],
    [0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1],
    [0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1],
    [0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1],
    [0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1],
    [0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1],
    [0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1],
    [0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1],
    [0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1],
    [0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1],
    [0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0],
    [0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0],
    [0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1],
    [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1],
    [0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1],
    [0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1],
    [0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1],
    [0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1],
    [0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1],
    [0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1],
    [0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1],
    [0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1],
    [1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1],
    [1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1],
    [1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0],
    [1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1],
    [1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1],
    [1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1],
    [1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1],
    [1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1],
    [1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1],
    [1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1],
    [1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0],
    [1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0],
    [1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0],
    [1, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0],
    [1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1],
    [1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1]
]


Y_good = [
    [1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1],
    [1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1],
    [1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1],
    [1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1]
]


def add_200_bits():
    for i in range(len(X_good)):
        for j in range(175):
            x_next = X_good[i][j] ^ X_good[i][j+3]
            X_good[i].append(x_next)
            
    # Y[k] ^ Y[k+1] ^ Y[k+2] ^ Y[k+6]
    for i in range(len(Y_good)):
        for j in range(174):
            y_next = Y_good[i][j] ^ Y_good[i][j+1] ^ Y_good[i][j+2] ^ Y_good[i][j+6]
            Y_good[i].append(y_next)
        
        
def reject(n3):
    indicator = True  
    f = open('L3.txt', 'a') # хендлер для файла в которую записываются "подходящии" посл-ти
    f1 = open('good.txt', 'a')
    itrtn = 0 # номер итерации = номер одного из кандидатов в заполнения L3
    number_of_cequences = 0 # кол-во "подходящих" последовательностей
    for vect in product((0,1),repeat=n3):
        itrtn += 1
        if itrtn < 48496640:
            if itrtn % (2**17) == 0:
                print(f'{number_of_cequences}\t{itrtn}/ {2**27}')
            continue
        if 1 not in vect: # пропускаем вектор (0,0, ..., 0,0)
            continue
        S = list(vect)

        # Для каждого нового "кандидата" в "правильное" заполнение L3 создаем 200-битовую последовательность
        for i in range(173):
            s_next = S[i] ^ S[i+1] ^ S[i+2] ^ S[i+5]
            S.append(s_next)

        for x in X_good: # берем одну из 200-бит. последовательностей L1
            for y in Y_good: # берем одну из 200-бит. последовательностей L2
                indicator = True
                for i in range(200): # рассматривает 200 битов последовательности
                    if x[i] == y[i]: 
                        continue # если i-е биты в последовательности одинаковы - такой случай нас не интересует
        
                    if Z[i] == x[i]:
                        if S[i] == 0: # != 1
                            indicator = False
                            break # такая послед-ть нам не подходит
        
                    if Z[i] == y[i]: 
                        if S[i] == 1: # != 0
                            indicator = False
                            break # такая послед-ть нам не подходит
                           
                # Если начальное заполнение прошло проверку - подходит       
                if indicator:
                    number_of_cequences += 1
                    print(f'{number_of_cequences}\t{itrtn}/ {2**27}')
                    f.write(f'{vect}\n')
                    f1.write(f'X = {x}\nY = {y}\nZ = {vect}\n')
                    f.close()
                    f1.close()
                    return 0
        # вывод - каждую 2^17 итерацию
        if itrtn % (2**17) == 0:
            print(f'{number_of_cequences}\t{itrtn}/ {2**27}') 

    f.close()
    f1.close()
    

    return -1


def main():
    # generate_x_i(25)
    # generate_y_i(26)
    # add_200_bits()
    # print(reject(27))
    
    

    compare()


    return 0 




if __name__ == "__main__":
    main()